{"version":3,"sources":["App.jsx","index.js"],"names":["sdk","ThirdwebSDK","bundleDropModule","getBundleDropModule","tokenModule","getTokenModule","voteModule","getVoteModule","App","useWeb3","connectWallet","address","error","provider","console","log","signer","getSigner","undefined","useState","hasClaimedNFT","setHasClaimedNFT","isClaiming","setIsClaiming","memberTokenAmounts","setMemberTokenAmounts","memberAddresses","setMemberAddresses","proposals","setProposals","isVoting","setIsVoting","hasVoted","setHasVoted","useEffect","retrieveProposals","a","getAll","checkVote","length","proposalId","grabAddresses","getAllClaimerAddresses","grabTokenAmounts","getAllHolderBalances","amounts","memberList","useMemo","map","tokenAmount","ethers","utils","formatUnits","setProviderOrSigner","checkMembershipNFT","balanceOf","balance","gt","UnsupportedChainIdError","className","onClick","align","member","str","substring","num","Number","toFixed","onSubmit","e","preventDefault","stopPropagation","votes","proposal","voteResult","vote","forEach","document","getElementById","type","checked","getDelegationOf","constants","AddressZero","delegateTo","Promise","all","get","state","execute","index","description","id","name","value","defaultChecked","htmlFor","label","disabled","mintNft","claim","ReactDOM","render","StrictMode","connectors","injected","supportedChainIds"],"mappings":"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","file":"static/js/main.c0e8fe10.chunk.js","sourcesContent":["import { useEffect, useMemo, useState } from \"react\";\nimport {ethers} from \"ethers\";\nimport { useWeb3 } from \"@3rdweb/hooks\";\nimport { ThirdwebSDK } from \"@3rdweb/sdk\";\nimport { UnsupportedChainIdError } from \"@web3-react/core\";\n\nconst sdk = new ThirdwebSDK(\"rinkeby\");\n\nconst bundleDropModule = sdk.getBundleDropModule(\n  \"0x5fa61ddbd6960AFFAf4A47d3cA565d661472530A\",\n);\n\nconst tokenModule = sdk.getTokenModule(\n  \"0x7941530260B55Bd6fC6d47c325b1F2788fabF3Cf\"\n);\n\nconst voteModule = sdk.getVoteModule(\n  \"0xc6A48D49a5e398fd5ff7Bf6329F4Fc53Fb3EFee0\",\n);\n\nconst App = () => {\n  const { connectWallet, address, error, provider } = useWeb3();\n  console.log(\"👋 Address:\", address)\n\n  // The signer is required to sign transactions on the blockchain.\n  // Without it we can only read data, not write.\n  const signer = provider ? provider.getSigner() : undefined;\n\n  const [hasClaimedNFT, setHasClaimedNFT] = useState(false);\n  // isClaiming lets us easily keep a loading state while the NFT is minting.\n  const [isClaiming, setIsClaiming] = useState(false);\n\n  // Holds the amount of token each member has in state.\n  const [memberTokenAmounts, setMemberTokenAmounts] = useState({});\n  // The array holding all of our members addresses.\n  const [memberAddresses, setMemberAddresses] = useState([]);\n\n  // A fancy function to shorten someones wallet address, no need to show the whole thing. \n  const shortenAddress = (str) => {\n    return str.substring(0, 6) + \"...\" + str.substring(str.length - 4);\n  };\n\n  const shortenAmount = (num) => {\n    return Number(num).toFixed(3);\n  }\n\n  const [proposals, setProposals] = useState([]);\n  const [isVoting, setIsVoting] = useState(false);\n  const [hasVoted, setHasVoted] = useState(false);\n\n  // Retrieve all our existing proposals from the contract.\n  useEffect(() => {\n    const retrieveProposals = async () => {\n      if (!hasClaimedNFT) {\n        return;\n      }\n      // A simple call to voteModule.getAll() to grab the proposals.\n      try {\n        const proposals = await voteModule.getAll();\n        setProposals(proposals);\n        console.log(\"🌈 Proposals:\", proposals);\n      } catch (error) {\n        console.log(\"failed to get proposals\", error);\n      }\n    }\n    retrieveProposals()\n  }, [hasClaimedNFT]);\n\n  // We also need to check if the user already voted.\n  useEffect(() => {\n    const checkVote = async () => {\n      if (!hasClaimedNFT) {\n        return;\n      }\n\n      // If we haven't finished retrieving the proposals from the useEffect above\n      // then we can't check if the user voted yet!\n      if (!proposals.length) {\n        return;\n      }\n\n      // Check if the user has already voted on the first proposal.\n      try {\n        const hasVoted = await voteModule.hasVoted(proposals[0].proposalId, address);\n        setHasVoted(hasVoted);\n        if(hasVoted) {\n          console.log(\"🥵 User has already voted\");\n        } else {\n          console.log(\"🙂 User has not voted yet\");\n        }\n      } catch (error) {\n        console.error(\"Failed to check if wallet has voted\", error);\n      } \n    }\n    checkVote()\n  }, [hasClaimedNFT, proposals, address]);\n\n  // This useEffect grabs all the addresses of our members holding our NFT.\n  useEffect(() => {\n    const grabAddresses = async () => {\n      if (!hasClaimedNFT) {\n        return;\n      }\n\n      // Just like we did in the 7-airdrop-token.js file! Grab the users who hold our NFT\n      // with tokenId 0.\n      try {\n        const memberAddresses = await bundleDropModule.getAllClaimerAddresses(\"0\");\n        setMemberAddresses(memberAddresses);\n        console.log(\"🚀 Members addresses\", memberAddresses);\n      } catch (error) {\n        console.error(\"failed to get member list\", error);\n      }\n    } \n    grabAddresses()\n  }, [hasClaimedNFT]);\n\n  // This useEffect grabs the # of token each member holds.\n  useEffect(() => {\n    const grabTokenAmounts = async () => {\n      if (!hasClaimedNFT) {\n        return;\n      }\n\n      // Grab all the balances.\n      try {\n        const amounts = await tokenModule.getAllHolderBalances();\n        setMemberTokenAmounts(amounts);\n        console.log(\"👜 Amounts\", amounts);\n      } catch (error) {\n        console.error(\"failed to get token amounts\", error);\n      }\n    }\n    grabTokenAmounts()\n  }, [hasClaimedNFT]);\n\n  // Now, we combine the memberAddresses and memberTokenAmounts into a single array\n  const memberList = useMemo(() => {\n    return memberAddresses.map((address) => {\n      return {\n        address,\n        tokenAmount: ethers.utils.formatUnits(\n          // If the address isn't in memberTokenAmounts, it means they don't\n          // hold any of our token.\n          memberTokenAmounts[address] || 0,\n          18,\n        ),\n      };\n    });\n  }, [memberAddresses, memberTokenAmounts]);\n\n  // Another useEffect!\n  useEffect(() => {\n    // We pass the signer to the sdk, which enables us to interact with\n    // our deployed contract!\n    sdk.setProviderOrSigner(signer);\n  }, [signer]);\n\n  // check if address has the membership NFT\n  useEffect(() => {\n    const checkMembershipNFT = async () => {\n      if(!address) {\n        return;\n      }\n\n      const balance = await bundleDropModule.balanceOf(address, \"0\");\n    \n      try {\n        if(balance.gt(0)) {\n            setHasClaimedNFT(true);\n            console.log(\"🌟 this user has a membership NFT!\");\n        } else {\n            setHasClaimedNFT(false);\n            console.log(\"😭 this user doesn't have a membership NFT.\")\n        }\n      } catch (error) {\n          setHasClaimedNFT(false);\n          console.error(\"failed to nft balance\", error);\n      }\n    } \n    checkMembershipNFT()\n  }, [address]);\n\n  if (error instanceof UnsupportedChainIdError ) {\n    return (\n      <div className=\"unsupported-network\">\n        <h2>Please connect to Rinkeby</h2>\n        <p>\n          This dapp only works on the Rinkeby network, please switch networks\n          in your connected wallet.\n        </p>\n      </div> \n    );\n  }\n\n  if (!address) {\n    return (\n      <div className=\"landing\">\n        <h1>Welcome to lolDAO</h1>\n        <button onClick={() => connectWallet(\"injected\")} className=\"btn-hero\">\n          Connect your wallet\n        </button>\n      </div>\n    );\n  }\n\n  // If the user has already claimed their NFT we want to display the interal DAO page to them\n  // only DAO members will see this. Render all the members + token amounts.\n  if (hasClaimedNFT) {\n    return (\n      <div className=\"member-page\">\n        <h1>🎉 lolDAO Member app 🎉 \n            \n        </h1>\n        <p><i>You are getting exclusive access to this page because you are one of the {memberList.length} lucky lolDAO members</i></p>\n        <div>\n          <div>\n            <h2>Member List</h2>\n            <table className=\"card\">\n              <thead>\n                <tr>\n                  <th>Address</th>\n                  <th align=\"right\">Token Amount</th>\n                </tr>\n              </thead>\n              <tbody>\n                {memberList.map((member) => {\n                  return (\n                    <tr key={member.address}>\n                      <td>{shortenAddress(member.address)}</td>\n                      <td align =\"right\">{shortenAmount(member.tokenAmount)}</td>\n                    </tr>\n                  );\n                })}\n              </tbody>\n            </table>\n          </div>\n          <div>\n            <h2>Active Proposals</h2>\n            <form\n              onSubmit={async (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n\n                //before we do async things, we want to disable the button to prevent double clicks\n                setIsVoting(true);\n\n                // lets get the votes from the form for the values\n                const votes = proposals.map((proposal) => {\n                  let voteResult = {\n                    proposalId: proposal.proposalId,\n                    //abstain by default\n                    vote: 2,\n                  };\n                  proposal.votes.forEach((vote) => {\n                    const elem = document.getElementById(\n                      proposal.proposalId + \"-\" + vote.type\n                    );\n\n                    if (elem.checked) {\n                      voteResult.vote = vote.type;\n                      return;\n                    }\n                  });\n                  return voteResult;\n                });\n\n                // first we need to make sure the user delegates their token to vote\n                try {\n                  //we'll check if the wallet still needs to delegate their tokens before they can vote\n                  const delegation = await tokenModule.getDelegationOf(address);\n                  // if the delegation is the 0x0 address that means they have not delegated their governance tokens yet\n                  if (delegation === ethers.constants.AddressZero) {\n                    //if they haven't delegated their tokens yet, we'll have them delegate them before voting\n                    await tokenModule.delegateTo(address);\n                  }\n                  // then we need to vote on the proposals\n                  try {\n                    await Promise.all(\n                      votes.map(async (vote) => {\n                        // before voting we first need to check whether the proposal is open for voting\n                        // we first need to get the latest state of the proposal\n                        const proposal = await voteModule.get(vote.proposalId);\n                        // then we check if the proposal is open for voting (state === 1 means it is open)\n                        if (proposal.state === 1) {\n                          // if it is open for voting, we'll vote on it\n                          return voteModule.vote(vote.proposalId, vote.vote);\n                        }\n                        // if the proposal is not open for voting we just return nothing, letting us continue\n                        return;\n                      })\n                    );\n                    try {\n                      // if any of the propsals are ready to be executed we'll need to execute them\n                      // a proposal is ready to be executed if it is in state 4\n                      await Promise.all(\n                        votes.map(async (vote) => {\n                          // we'll first get the latest state of the proposal again, since we may have just voted before\n                          const proposal = await voteModule.get(\n                            vote.proposalId\n                          );\n\n                          //if the state is in state 4 (meaning that it is ready to be executed), we'll execute the proposal\n                          if (proposal.state === 4) {\n                            return voteModule.execute(vote.proposalId);\n                          }\n                        })\n                      );\n                      // if we get here that means we successfully voted, so let's set the \"hasVoted\" state to true\n                      setHasVoted(true);\n                      // and log out a success message\n                      console.log(\"successfully voted\");\n                    } catch (err) {\n                      console.error(\"failed to execute votes\", err);\n                    }\n                  } catch (err) {\n                    console.error(\"failed to vote\", err);\n                  }\n                } catch (err) {\n                  console.error(\"failed to delegate tokens\");\n                } finally {\n                  // in *either* case we need to set the isVoting state to false to enable the button again\n                  setIsVoting(false);\n                }\n              }}\n            >\n              {proposals.map((proposal, index) => (\n                <div key={proposal.proposalId} className=\"card\">\n                  <h5>{proposal.description}</h5>\n                  <div>\n                    {proposal.votes.map((vote) => (\n                      <div key={vote.type}>\n                        <input\n                          type=\"radio\"\n                          id={proposal.proposalId + \"-\" + vote.type}\n                          name={proposal.proposalId}\n                          value={vote.type}\n                          //default the \"abstain\" vote to chedked\n                          defaultChecked={vote.type === 2}\n                        />\n                        <label htmlFor={proposal.proposalId + \"-\" + vote.type}>\n                          {vote.label}\n                        </label>\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              ))}\n              <button disabled={isVoting || hasVoted} type=\"submit\">\n                {isVoting\n                  ? \"Voting...\"\n                  : hasVoted\n                    ? \"You Already Voted\"\n                    : \"Submit Votes\"}\n              </button>\n              <small>\n                This will trigger multiple transactions that you will need to\n                sign.\n              </small>\n            </form>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const mintNft = async () => {\n    setIsClaiming(true);\n    try {\n      // Call bundleDropModule.claim(\"0\", 1) to mint nft to user's wallet.\n      await bundleDropModule.claim(\"0\",1);\n      // Set claim state.\n      setHasClaimedNFT(true);\n      // Show user their fancy new NFT!\n      console.log(`🌊 Successfully Minted! Check it out on OpenSea: https://testnets.opensea.io/assets/${bundleDropModule.address}/0`);\n    } catch (error) {\n      console.error(\"failed to claim\", error);\n    } finally {\n      // Stop loading state.\n      setIsClaiming(false);\n    }\n  }\n\n  // Render mint nft screen.\n  return (\n    <div className=\"mint-nft\">\n      <h1>Mint your free 🍪DAO Membership NFT</h1>\n      <button\n        disabled={isClaiming}\n        onClick={() => mintNft()}\n      >\n        {isClaiming ? \"Minting...\" : \"Mint your nft (FREE)\"}\n      </button>\n    </div>\n  );\n};\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Import ThirdWeb\nimport { ThirdwebWeb3Provider } from '@3rdweb/hooks';\n\n// Include what chains you wanna support.\n// 4 = Rinkeby.\nconst supportedChainIds = [4];\n\n// Include what type of wallet you want to support.\n// In this case, we support Metamask which is an \"injected wallet\".\nconst connectors = {\n  injected: {},\n};\n\n// Finally, wrap App with ThirdwebWeb3Provider.\nReactDOM.render(\n  <React.StrictMode>\n    <ThirdwebWeb3Provider\n      connectors={connectors}\n      supportedChainIds={supportedChainIds}\n    >\n      <App />\n    </ThirdwebWeb3Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}